apiVersion: v1
kind: ConfigMap
metadata:
  name: hummingbot-config
  namespace: trading
data:
  conf_global.yml: |
    instance_id: aster_mm_001
    log_level: INFO
    debug_mode: false

    exchanges:
      asterdex:
        api_key: ""
        api_secret: ""
        sandbox_mode: true
        trading_required: true

    telegram:
      enabled: true
      token: ""
      chat_id: ""

    gateway:
      enabled: true
      port: 1902
      host: 0.0.0.0

    scripts:
      - aster_market_maker.py
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: hummingbot-scripts
  namespace: trading
data:
  aster_market_maker.py: |
    import asyncio
    import logging
    from decimal import Decimal
    from typing import Dict, List, Optional

    from hummingbot.core.data_type.common import OrderType, TradeType
    from hummingbot.core.data_type.order_candidate import OrderCandidate
    from hummingbot.core.event.events import BuyOrderCompletedEvent, SellOrderCompletedEvent
    from hummingbot.script.script_base import ScriptBase
    from hummingbot.strategy.script_strategy_base import ScriptStrategyBase

    class AsterMarketMaker(ScriptStrategyBase):
        """
        HFT Market Making Strategy for Aster DEX
        Focuses on high-volume, small-profit trades with Rh point optimization
        """

        # Configuration
        spread_pct: float = 0.005  # 0.5% spread
        order_amount: float = 50.0  # Base order size in USDT
        max_orders_per_side: int = 5
        inventory_skew_enabled: bool = True
        inventory_target_pct: float = 0.1  # Target 10% of portfolio per asset

        # Risk controls
        max_inventory_pct: float = 0.15  # Max 15% of portfolio per asset
        min_order_refresh_time: float = 30.0  # Minimum time between order refreshes
        max_slippage_pct: float = 0.002  # Max 0.2% slippage

        markets = {
            "asterdex_btc-usdt": {"exchange": "asterdex", "trading_pair": "BTC-USDT"},
            "asterdex_eth-usdt": {"exchange": "asterdex", "trading_pair": "ETH-USDT"},
        }

        def __init__(self, connectors: Dict[str, any], config: Dict[str, any]):
            super().__init__(connectors, config)
            self.last_order_refresh = {}
            self.inventory_targets = {}

        def on_tick(self):
            """Main strategy loop - called on every tick"""
            for market_name, market_info in self.markets.items():
                connector = self.connectors[market_info["exchange"]]
                trading_pair = market_info["trading_pair"]

                # Check if we need to refresh orders
                if self._should_refresh_orders(market_name):
                    self._refresh_market_making_orders(connector, trading_pair, market_name)

                # Check inventory skew
                if self.inventory_skew_enabled:
                    self._adjust_inventory_skew(connector, trading_pair)

        def _should_refresh_orders(self, market_name: str) -> bool:
            """Check if orders need refreshing"""
            current_time = self.current_timestamp
            last_refresh = self.last_order_refresh.get(market_name, 0)
            return current_time - last_refresh >= self.min_order_refresh_time

        def _refresh_market_making_orders(self, connector, trading_pair: str, market_name: str):
            """Refresh market making orders for a trading pair"""
            try:
                # Get current market data
                mid_price = self._get_mid_price(connector, trading_pair)
                if mid_price is None:
                    return

                # Cancel existing orders
                self._cancel_existing_orders(connector, trading_pair)

                # Create new order ladder
                self._create_order_ladder(connector, trading_pair, mid_price)

                # Update refresh timestamp
                self.last_order_refresh[market_name] = self.current_timestamp

            except Exception as e:
                self.logger.error(f"Error refreshing orders for {trading_pair}: {e}")

        def _get_mid_price(self, connector, trading_pair: str) -> Optional[float]:
            """Get mid price for a trading pair"""
            try:
                order_book = connector.get_order_book(trading_pair)
                best_bid = order_book.best_bid.price
                best_ask = order_book.best_ask.price
                return (best_bid + best_ask) / 2
            except Exception as e:
                self.logger.warning(f"Could not get mid price for {trading_pair}: {e}")
                return None

        def _cancel_existing_orders(self, connector, trading_pair: str):
            """Cancel all existing orders for a trading pair"""
            try:
                orders = connector.get_orders(trading_pair)
                for order in orders:
                    if order.is_open:
                        connector.cancel_order(order.id)
            except Exception as e:
                self.logger.error(f"Error canceling orders for {trading_pair}: {e}")

        def _create_order_ladder(self, connector, trading_pair: str, mid_price: float):
            """Create a ladder of buy and sell orders around mid price"""
            spread_amount = mid_price * self.spread_pct

            # Create buy orders
            for i in range(self.max_orders_per_side):
                price = mid_price - (spread_amount * (i + 1))
                amount = self._calculate_order_amount(trading_pair, price, "buy")

                if amount > 0:
                    order_candidate = OrderCandidate(
                        trading_pair=trading_pair,
                        is_maker=True,
                        order_type=OrderType.LIMIT,
                        order_side=TradeType.BUY,
                        amount=amount,
                        price=price,
                    )
                    self.place_order(connector, order_candidate)

            # Create sell orders
            for i in range(self.max_orders_per_side):
                price = mid_price + (spread_amount * (i + 1))
                amount = self._calculate_order_amount(trading_pair, price, "sell")

                if amount > 0:
                    order_candidate = OrderCandidate(
                        trading_pair=trading_pair,
                        is_maker=True,
                        order_type=OrderType.LIMIT,
                        order_side=TradeType.SELL,
                        amount=amount,
                        price=price,
                    )
                    self.place_order(connector, order_candidate)

        def _calculate_order_amount(self, trading_pair: str, price: float, side: str) -> float:
            """Calculate order amount with inventory skew consideration"""
            base_amount = self.order_amount / price

            if self.inventory_skew_enabled:
                # Adjust based on inventory target
                current_inventory = self._get_current_inventory(trading_pair)
                target_inventory = self.inventory_targets.get(trading_pair, 0)

                if side == "buy" and current_inventory > target_inventory:
                    # Reduce buy orders if over-inventoried
                    base_amount *= 0.5
                elif side == "sell" and current_inventory < target_inventory:
                    # Reduce sell orders if under-inventoried
                    base_amount *= 0.5

            return min(base_amount, self._get_max_order_amount(trading_pair))

        def _get_current_inventory(self, trading_pair: str) -> float:
            """Get current inventory for a trading pair"""
            try:
                base_asset = trading_pair.split("-")[0]
                balance = self.connectors["asterdex"].get_balance(base_asset)
                return balance.available
            except Exception:
                return 0.0

        def _get_max_order_amount(self, trading_pair: str) -> float:
            """Get maximum allowed order amount based on risk controls"""
            # This would integrate with portfolio risk management
            return self.order_amount * 2  # Simplified

        def _adjust_inventory_skew(self, connector, trading_pair: str):
            """Adjust inventory toward target levels"""
            try:
                current_inventory = self._get_current_inventory(trading_pair)
                target_inventory = self.inventory_targets.get(trading_pair, current_inventory)

                if abs(current_inventory - target_inventory) / target_inventory > 0.05:  # 5% threshold
                    # Place inventory adjustment order
                    self._place_inventory_adjustment_order(connector, trading_pair, current_inventory, target_inventory)

            except Exception as e:
                self.logger.error(f"Error adjusting inventory for {trading_pair}: {e}")

        def _place_inventory_adjustment_order(self, connector, trading_pair: str, current: float, target: float):
            """Place order to adjust inventory toward target"""
            adjustment_amount = target - current

            if abs(adjustment_amount) < 0.001:  # Minimum adjustment threshold
                return

            mid_price = self._get_mid_price(connector, trading_pair)
            if mid_price is None:
                return

            # Place market order to adjust inventory
            if adjustment_amount > 0:  # Need to buy
                order_candidate = OrderCandidate(
                    trading_pair=trading_pair,
                    is_maker=False,  # Market order for quick execution
                    order_type=OrderType.MARKET,
                    order_side=TradeType.BUY,
                    amount=min(abs(adjustment_amount), self._get_max_order_amount(trading_pair)),
                    price=mid_price * 1.001,  # Slightly above mid for taker
                )
            else:  # Need to sell
                order_candidate = OrderCandidate(
                    trading_pair=trading_pair,
                    is_maker=False,
                    order_type=OrderType.MARKET,
                    order_side=TradeType.SELL,
                    amount=min(abs(adjustment_amount), self._get_max_order_amount(trading_pair)),
                    price=mid_price * 0.999,  # Slightly below mid for taker
                )

            self.place_order(connector, order_candidate)

        def on_buy_order_completed(self, event: BuyOrderCompletedEvent):
            """Handle buy order completion"""
            self.logger.info(f"Buy order completed: {event.order_id} - {event.trading_pair}")

        def on_sell_order_completed(self, event: SellOrderCompletedEvent):
            """Handle sell order completion"""
            self.logger.info(f"Sell order completed: {event.order_id} - {event.trading_pair}")

        def on_stop(self):
            """Cleanup when strategy stops"""
            self.logger.info("Aster Market Maker stopping...")
            # Cancel all open orders
            for market_name, market_info in self.markets.items():
                connector = self.connectors[market_info["exchange"]]
                trading_pair = market_info["trading_pair"]
                self._cancel_existing_orders(connector, trading_pair)
